[Kap 1:]
Basics
- 2.(2) Operatoren
- 3.(4) Variablen (typen, gültige Namen)
- 6.(6) atomare vektoren (seq, rep, indizierung, NA)
- 6.8(11) text (print, cat)
- 7.(12) funktionen
- 8.(13) listen (str, c, unlist, as.list
- 9.(16) if, while, for (seq_along, letters)
-10.(18) Zufall
-11.(20) summary statistics (mean, median, var, sd, max, which.max, summary)
-12.(21) Matrizen
-13.(23) basegraphics plot
-14.(26) pakete
-15.(27) tibble (erstellung, indizierung, 
-16.(28) apply Funktionen (lapply, sapply, apply(mat, 1/2, f)
-17.(29) Statistik

[Kap 2:]
Datenstrukturen
- 1.(1) Objekte (typeof, class, length)
- 2.(2) Vektoren 
	- atomare (basistypen, initialisierung BASETYPE(n), typtest)
	- logical(3), integer(4), double(4), character(6) (letters, month.name)
	- coercion(8)
	- listen(8) (initialisierung list()
- 3.(10) Attribute (attr, attributes, structure, str)
	- names (11) (atomare vektoren oder listen)
- 4.(14) Matrizen und Arrays (dim, nrow, ncol, rbind, cbind, abind::abind())
- 5.(19) S3-Objekte (factor, date time zeug)
- 6.(22) Tibbles
- 9.(25) Na zeug

[Kap 3:]
Subsetting
- 1.(1) mehrere Elemente
	- 2.1(1) atomare Vektoren
	- 2.2(4) Arrays	
	- 2.3(8) Tibbles
- 2.(9) einzelne Elemente
	- 3.1(9) [[
	- 3.2(10) $
- 4.(11) fehlende indizes
- 5.(12) subsetting und zuweisung, out-of-bounds-zuweisung 
- 6.(15) Anwendungen
	- 6.2(15) Matching und Merging
	- 6.3(16) Random Samples
	- 6.4(17) Sortieren (sort, order, rank)
	- 6.5(18) Aggregierte Zeilen expandieren
	- 6.6(18) Spalten aus Tibble entfernen
	- 6.7(19) Konditionales Subsetting
	- 6.8(19) Boolean/Integer Subsetting (which)

[Kap 4:]
Funktionen
1.(1) nomenklatur, syntax
2.(3) Funktionsaufruf (präfix, infix, ersetzungsfunktionen, vordefinierte spezialfunktionen, do.call)
3.(7) Klassifizierung (class function, typeof closure/builtin/special)
4.(8) Komponenten
5.(9) Funktionsargumente (lazy evaluation, default arguments, missing arguments, ...)
6.(12) Beenden einer Funktion

[Kap 5:]
stringr (teil von tidyverse, also klausurrelevant)
2.(1) Basics (str_length, str_c, str_sub, str_trim, str_squish, str_to_upper, ...)
3.(3) Formatieren (str_glue, str_glue_data, ...)
4.(4) regexp (str_view, str_view_all)
	4.1(5) Funktionen (str_detect, str_subset, str_which, str_count)
	4.2(7) Syntax (siehe stringr_cheatsheet.pdf)

[Kap 6:]
tibble
1.(1) Tabellen (erstellen, as_tibble, add_column, add_row, subsetting, bind_rows, bind_cols
2.(6) Relationale Datenbanken (union, intersect, setdiff, crossing)

[Kap 7:]
dplyr
1.(1) Verben für eine Tabelle (filter, arrange, select, mutate, summarize, pipe, monit	set	
group_by, column/row-wise operations: across/rowwise, non-standard-evaluation)
2.(23) Verben für zwei Tabellen (mutating: left/right/full/inner_join, filtering: semi/anti_join)
3.(28) Relationale Datenbanken

[Kap 8:]
tidyr
1.1(3) pivoting
1.2(5) separate and unite
1.3(7) Fehlende Werte
2(9) Normalisierung Relationaler Datenbanken (mega unnötig)

[Kap 9:]
Umgebungen
3(2) Umgebungsobjekte (rlang ist auch klausurrelevant)
4(6) Umgebungsdiagramme
5(8) Funktionsumgebungen (funktions-, aufrufende, ausführungs-)
6(14) Scoping-Prinzipien (überdeckung, dynamic lookup, ausführungsumgebung)
7(17) Zuweisungsoperatoren (<-, <<-, ->, ->>, =)
8(18) Elternumgebungen, suchpfad
9(19) paketumgebungen
10(22) Übersicht
11(22) Lazy evaluation

[Kap 10:]
Funktionale Programmierung
1(1) Funktionale Programmierung, rein(3), 
2(5) Funktionale (apply-funktionen, rep, outer(12), integrate, optim)
3(15) Funktionsfabriken (Counter, MLS, Interpolation)
4(22) Funktionsoperatoren

[Kap 11:]
Objektorientierte Programmierung
1(1) Intro
2(3) S3
3(13)S4
4(18)R6

[Kap 12:]
2(2) Ausdrücke, Syntaxbaum, parse, base-R 
3(7) Ausdrücke verwenden, enexpr, eval (mit Umgebung), quosures(9)
4(11)Anwendung
5(12)tidy-eval-framework, !!, !!!, {{}}, :=
